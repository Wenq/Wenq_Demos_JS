# 2024/1/21 补充：
整书：
第一篇（1、2章）讲js中oop思想及其实现，是打语言基础，为后续讲解具体设计模式实现做准备；
第二～六篇（3～40章）都是讲设计模式，共分5大类38章节；

=============================================

# 2024/1/18
阅读了第118页的观察者模式内容

作功能模块实现，分析方法还是要走面向对象方法

# 2024/1/20 第一章 灵活的语言 - Javascript

## 把多个挂全局对象window上的function统一到一个window.xx对象/变量下，更加方便管理，function被覆盖风险更低，如果被覆盖也更容易察觉；

//写法1:在一个对象上创建函数
var CheckObject = {
    checkName : function(){
        //xxx
    }
}
用法：CheckObject.checkName()

//写法2:在一个函数上创建函数
var CheckObject = function(){}
CheckObject.checkName = function(){
    //xxx
}
用法：CheckObject.checkName()

`结论`：`函数也是变量`

//写法3: 返回一个对象
var CheckObject = function(){
    return {
        checkName : function(){
            //xxx
        }
    }
}
用法：CheckObject().checkName()
备注：每次ChckObject返回的都是一个新对象，整体是一个函数类型变量

`感受`：`链式调用`实现的重点是每一次调用返回的都是当前对象本身，即this

//写法4:类的方式
var CheckObject = function(){
    this.checkName = function(){
        //xxx
    }
}
用法：new CheckObject().checkName();  //类，用new创建（示例化）
备注：通过this定义的函数，用new关键字创建时会对this上的属性进行复制，即面向对象中类的定义与实例化

//写法5:类的其他实现方式
var CheckObject = function(){}
CheckObject.prototype.checkName = function(){
    //xxx
}
或者
var CheckObject = function(){}
CheckObject.prototype = {
    checkName : function(){
        //xxx
    },
    checkEmail : function(){
        //xxx
    }
}
用法：与写法4相同
备注：使用原型prototype实现类,比写法4性能更好（消耗低）

//写法5支持链式调用
var CheckObject = function(){}
CheckObject.prototype = {
    checkName : function(){
        //xxx
        return this;
    },
    checkEmail : function(){
        //xxx
        return this;
    }
}
链式调用：new CheckObject().checkName().checkEmail();

### 知识 - prototype.js框架

是一款js框架，封装了很多方法，用于扩展原生对象（比如Function、Arrya、Obejct等）

比如在原生Function对象上统一新增一个函数，这样任意地方都可以调用：
Fucntion.prototype.checkMail = function(){
    //xxx
}

备注：这种扩展也是对原生对象Function的`污染`

避免污染方法：
在Function原型上实现一个addMethod用于给实例对象动态添加函数，代码如下
Function.prototype.addMethod = function(name, fun){
    this[name] = fun;
}
使用示例：
var methods = new Function();
methods.addMethod = ('checkName', function(){
    //xxx
})
//调用动态增加的函数
methdos.checkName();
备注：这样做虽然也在Function的原型上添加了函数，但函数与具体业务逻辑无关

`总结`：js是一种灵活语言，`函数`在其中扮演非常重要的作用，是顶级元素；
`我的疑惑`： CheckObject().checkName() 与 new CheckObject().checkName()的区别是什么？ 什么时候需要用new关键字创建对象？

# 第二章 写的都是看到的 - 面向对象

面向过程 VS 面向对象

### 面向过程：
1、编写一个一个函数解决需求
2、添加了很多全局变量，不利于后期扩展
3、不利于复用
4、不利于团队代码维护
### 面向过程：
1、抽象需求为对象
2、分析对象特性，包括属性和方法

### 重要知识
`js这种解释性的弱类型语言没有经典强类型语言中那种通过class等关键字实现的类的封装方式，js中都是通过一些特性模仿实现的，但这也带来了极高的灵活性，让我们编写的代码更自由`

js中模仿的oop特性：封装、继承

# 2024/1/21 20号已经粗略看过一次封装/继承内容

## 封装
`在js中创建类`：
生命一个函数，函数保存在一个变量里，在这个函数/类的内部通过对this（函数内部变量，指向函数本身）变量添加属性或方法来实现对雷添加属性或方法。代码示例如下（封装类Book）
//封装类、类的属性
var Book = funtion(id, bookname, price){
    this.id = id;
    this.bookname = bookname;
    this.price = price;
    <!-- this.doSomeThing = fucntion(){
        //xxx
    } -->
}
//封装类的方法
通过在类的原型（类也是一个对象，所以也原型prototype）上添加属性和方法。有两种方式，一为为原型对象属性赋值，二为将一个对象赋值给类的原型对象。代码示例：
Book.prototype.display = funtion(){
    //xxx
}
或
Book.prototype = {
    display : function(){
        //xxx
    }
}
以上两种方法是在“类”里面创建方法/函数
注意：
1、`js中类是通过js的特性来模仿出来的，本身并没有类这种类型`
2、每一种对象都有原型prototype，函数function也是一种对象

使用上面封装的Book类：
不能直接使用，要用`new`关键字来实例化（创建）新的对象。示例如下
var book = new Book('111', '设计模式'，50);
console.log(book.bookname);

`重要问题`：
通过this添加的属性和方法，与通过原型prototype添加的属性和方法，其差异是什么？
答：
1、通过this添加的属性和方法，都是添加在当前对象上的（是对象自身拥有的）。当创建该对象的实例时，这些属性和方法会被复制（创建一份）给到实例（复制过程是有消耗的）；
2、通过原型prototype继承的属性和方法是每个对象通过prototype访问到的，所以创建类的实例（新对象）时，这些属性和方法不会再次创建。都是通过prototype一级一级查找得来的，即是在原型prototype上有一份公共的，无需每次创建（消耗更低）。

`重要基础知识`：
js是一种基于原型prototype的语言，每次创建一个对象时（js中函数也是一种对象），他都有一个原型prototype用于指向其继承的属性，方法。通过prototype继承的方法并不是对象自身的。使用这些方法时，需通过prototype一级一级查找。

`Book类及其实例book关系解析示例解析`
如上创建的类Book，其实例对象book：
其属性（id，bookname，price）都会被复制一份到实例对象book中，但方法display不会复制到book中。如果book实例要访问display方法，需要通过book实例中prototype对象“_proto_”去往上一级一级寻找，直到找到display方法

### Book类中constructor是什么？
constructor是一个属性，当创建一个函数或对象时都会为其创建一个原型对象prototype，在prototype对象中会创建一个constructor属性，该属性指向拥有整个原型对象的函数或对象。
如上面例子，`prototype指向Book类对象`。

`感受`：
类/对象A - this
类/对象A - prototype - constructor(指向类/对象A)

高级语言如C#、java中其对象包含的属性和方法访问级别为：
private - 私有，只有对象内部可以访问
protected - 保护，只有对象自己可以访问
public - 公共/共有，外部对象可以访问
static - 静态属性或方法，全局只有一份

`js语言本身没有class，也没有private等几种访问级别控制，而是通过一些灵活的技巧来实现的`。就如同使用特性来模拟的类，本身并不直接支持。

js实现private、protected、public、static的方法：
js的`函数级作用域`:
1、声明在函数内部的变量和方法在外部是访问不到的，通过此特性即可创建类的私有变量和私有方法；
2、在函数内部通过this创建的属性和方法，在类创建对象时每个对象自身都拥有一份并且可在外部访问。因此通过this创建的属性和方法是对象共有属性和共有方法。通过this创建的方法，不但可以访问对象的共有属性和共有方法，还可访问到私有属性和私有方法，由于这些方法权利比较大，又叫做`特权方法`（共有方法又叫做特权方法）。
`特权方法`可用于初始化实例对象的一些属性，因此在创建对象时调用的特权方法看作是`类的构造器`。
3、
4、


`js：private` - 在函数内部声明变量和方法
var Book = function(){
    //私有属性
    var price = 10;
    //私有方法
    var display = function(){
        //xxx
    };
    //私有方法
    fucntion checkId(){
        //xxx
    }
}
`js：public` - 通过this创建属性和方法
js：public - 通过this创建的属性和方法 或 给类的prototype赋值
方法一：
var Book = function(id, name, price){
    //公有属性
    this.price = 10;
    //公有方法
    this.display = function(){
        //xxx
    };
    this.setName = function(){};
    this.setPrice = function(){};
    //构造器
    this.setName(name);
    this.setPrice(price);
}
方法二：
Book.prototype = {
    //公有属性
    isJSBook : false,
    //公有方法
    display : function(){}
}
`js：protected` - 不涉及
`js：static` - 通过类加点语法创建
//类静态公有属性（对象不能访问）
Book.isChinese = true;
//类静态公有方法（对象不能访问）
Book.resetTime = function(){};

`结论`：通过js函数级作用域的特征来实现在函数内部创建外界访问不到的私有化变量和私有方法。

摘抄:
通过new关键字创建的对象实质是对新对象this的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法语法定义的属性方法是不会添加到新创建的对象上去的。因此想在新创建对象上使用isChinese的通过Book类访问而不是this，如Book.isChinese，而`类的原型prototype上定义的属性在新对象里可直接使用，这是因为新对象的prototype和类的protyotype指向同一个对象`。
var b = new Book(xxx);
b.isJSBook  //可正常访问

`疑问`：
1、通过new关键字创建对象，为什么类外面通过点语法（Book.isChinese）添加的属性和方法不会被执行到？
2、new关键字是一个什么实现原理？

# 2024/1/25 new关键字实现
参考链接：https://www.jianshu.com/p/4bbf0c582e97

js中new关键字用来创建一个类（模拟类）的实例对象。

js中使用new关键字创建新对象，实际做了如下`4件事`：
1、创建一个新的空对象 {}
2、设置这个对象原型指向构造函数， 即上例中的obj.__proto = Person.prototype
3、执行构造函数， 当this关键字被提及的时候， 使用新创建的对象的属性
4、返回新创建的对象

疑问：call关键字实现原理是什么？

## 闭包实现 `重点知识`


## 继承


## 多态







