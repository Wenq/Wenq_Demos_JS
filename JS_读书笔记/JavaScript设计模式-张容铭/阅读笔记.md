# 2024/1/21 补充：
整书：
第一篇（1、2章）讲js中oop思想及其实现，是打语言基础，为后续讲解具体设计模式实现做准备；
第二～六篇（3～40章）都是讲设计模式，共分5大类38章节；

=============================================

# 2024/1/18
阅读了第118页的观察者模式内容

作功能模块实现，分析方法还是要走面向对象方法

# 2024/1/20 第一章 灵活的语言 - Javascript

## 把多个挂全局对象window上的function统一到一个window.xx对象/变量下，更加方便管理，function被覆盖风险更低，如果被覆盖也更容易察觉；

//写法1:在一个对象上创建函数
var CheckObject = {
    checkName : function(){
        //xxx
    }
}
用法：CheckObject.checkName()

//写法2:在一个函数上创建函数
var CheckObject = function(){}
CheckObject.checkName = function(){
    //xxx
}
用法：CheckObject.checkName()

`结论`：`函数也是变量`

//写法3: 返回一个对象
var CheckObject = function(){
    return {
        checkName : function(){
            //xxx
        }
    }
}
用法：CheckObject().checkName()
备注：每次ChckObject返回的都是一个新对象，整体是一个函数类型变量

`感受`：`链式调用`实现的重点是每一次调用返回的都是当前对象本身，即this

//写法4:类的方式
var CheckObject = function(){
    this.checkName = function(){
        //xxx
    }
}
用法：new CheckObject().checkName();  //类，用new创建（示例化）
备注：通过this定义的函数，用new关键字创建时会对this上的属性进行复制，即面向对象中类的定义与实例化

//写法5:类的其他实现方式
var CheckObject = function(){}
CheckObject.prototype.checkName = function(){
    //xxx
}
或者
var CheckObject = function(){}
CheckObject.prototype = {
    checkName : function(){
        //xxx
    },
    checkEmail : function(){
        //xxx
    }
}
用法：与写法4相同
备注：使用原型prototype实现类,比写法4性能更好（消耗低）

//写法5支持链式调用
var CheckObject = function(){}
CheckObject.prototype = {
    checkName : function(){
        //xxx
        return this;
    },
    checkEmail : function(){
        //xxx
        return this;
    }
}
链式调用：new CheckObject().checkName().checkEmail();

### 知识 - prototype.js框架

是一款js框架，封装了很多方法，用于扩展原生对象（比如Function、Arrya、Obejct等）

比如在原生Function对象上统一新增一个函数，这样任意地方都可以调用：
Fucntion.prototype.checkMail = function(){
    //xxx
}

备注：这种扩展也是对原生对象Function的`污染`

避免污染方法：
在Function原型上实现一个addMethod用于给实例对象动态添加函数，代码如下
Function.prototype.addMethod = function(name, fun){
    this[name] = fun;
}
使用示例：
var methods = new Function();
methods.addMethod = ('checkName', function(){
    //xxx
})
//调用动态增加的函数
methdos.checkName();
备注：这样做虽然也在Function的原型上添加了函数，但函数与具体业务逻辑无关

`总结`：js是一种灵活语言，`函数`在其中扮演非常重要的作用，是顶级元素；
`我的疑惑`： CheckObject().checkName() 与 new CheckObject().checkName()的区别是什么？ 什么时候需要用new关键字创建对象？

# 第二章 写的都是看到的 - 面向对象

面向过程 VS 面向对象

### 面向过程：
1、编写一个一个函数解决需求
2、添加了很多全局变量，不利于后期扩展
3、不利于复用
4、不利于团队代码维护
### 面向过程：
1、抽象需求为对象
2、分析对象特性，包括属性和方法

### 重要知识
`js这种解释性的弱类型语言没有经典强类型语言中那种通过class等关键字实现的类的封装方式，js中都是通过一些特性模仿实现的，但这也带来了极高的灵活性，让我们编写的代码更自由`

js中模仿的oop特性：封装、继承

# 2024/1/21 20号已经粗略看过一次封装/继承内容

## 封装
`在js中创建类`：
生命一个函数，函数保存在一个变量里，在这个函数/类的内部通过对this（函数内部变量，指向函数本身）变量添加属性或方法来实现对雷添加属性或方法。代码示例如下
var Book = funtion(id, bookname, price){
    this.id = id;
    this.bookname = bookname;
    this.price = price;
    <!-- this.doSomeThing = fucntion(){
        //xxx
    } -->
}


通过在类的原型（类也是一个对象，所以也原型prototype）上添加属性和方法。有两种方式，一为为原型对象属性赋值，二为将一个对象赋值给类的原型对象。代码示例：
Book.prototype.display = funtion(){
    //xxx
}
或
Book.prototype = {
    display : function(){
        //xxx
    }
}
以上两种方法是在“类”里面创建方法/函数
注意：`js中类是通过js的特性来模仿出来的，本身并没有类这种类型`


## 闭包实现 `重点知识`


## 继承


## 多态







