# 2024/1/21 补充：
整书：
第一篇（1、2章）讲js中oop思想及其实现，是打语言基础，为后续讲解具体设计模式实现做准备；
第二～六篇（3～40章）都是讲设计模式，共分5大类38章节；

=============================================

# 2024/1/18
阅读了第118页的观察者模式内容

作功能模块实现，分析方法还是要走面向对象方法

# 2024/1/20 第一章 灵活的语言 - Javascript

## 把多个挂全局对象window上的function统一到一个window.xx对象/变量下，更加方便管理，function被覆盖风险更低，如果被覆盖也更容易察觉；

//写法1:在一个对象上创建函数
var CheckObject = {
    checkName : function(){
        //xxx
    }
}
用法：CheckObject.checkName()

//写法2:在一个函数上创建函数
var CheckObject = function(){}
CheckObject.checkName = function(){
    //xxx
}
用法：CheckObject.checkName()

`结论`：`函数也是变量`

//写法3: 返回一个对象
var CheckObject = function(){
    return {
        checkName : function(){
            //xxx
        }
    }
}
用法：CheckObject().checkName()
备注：每次ChckObject返回的都是一个新对象，整体是一个函数类型变量

`感受`：`链式调用`实现的重点是每一次调用返回的都是当前对象本身，即this

//写法4:类的方式
var CheckObject = function(){
    this.checkName = function(){
        //xxx
    }
}
用法：new CheckObject().checkName();  //类，用new创建（示例化）
备注：通过this定义的函数，用new关键字创建时会对this上的属性进行复制，即面向对象中类的定义与实例化

//写法5:类的其他实现方式
var CheckObject = function(){}
CheckObject.prototype.checkName = function(){
    //xxx
}
或者
var CheckObject = function(){}
CheckObject.prototype = {
    checkName : function(){
        //xxx
    },
    checkEmail : function(){
        //xxx
    }
}
用法：与写法4相同
备注：使用原型prototype实现类,比写法4性能更好（消耗低）

//写法5支持链式调用
var CheckObject = function(){}
CheckObject.prototype = {
    checkName : function(){
        //xxx
        return this;
    },
    checkEmail : function(){
        //xxx
        return this;
    }
}
链式调用：new CheckObject().checkName().checkEmail();

### 知识 - prototype.js框架

是一款js框架，封装了很多方法，用于扩展原生对象（比如Function、Arrya、Obejct等）

比如在原生Function对象上统一新增一个函数，这样任意地方都可以调用：
Fucntion.prototype.checkMail = function(){
    //xxx
}

备注：这种扩展也是对原生对象Function的`污染`

避免污染方法：
在Function原型上实现一个addMethod用于给实例对象动态添加函数，代码如下
Function.prototype.addMethod = function(name, fun){
    this[name] = fun;
}
使用示例：
var methods = new Function();
methods.addMethod = ('checkName', function(){
    //xxx
})
//调用动态增加的函数
methdos.checkName();
备注：这样做虽然也在Function的原型上添加了函数，但函数与具体业务逻辑无关

`总结`：js是一种灵活语言，`函数`在其中扮演非常重要的作用，是顶级元素；
`我的疑惑`： CheckObject().checkName() 与 new CheckObject().checkName()的区别是什么？ 什么时候需要用new关键字创建对象？

# 第二章 写的都是看到的 - 面向对象

面向过程 VS 面向对象

### 面向过程：
1、编写一个一个函数解决需求
2、添加了很多全局变量，不利于后期扩展
3、不利于复用
4、不利于团队代码维护
### 面向过程：
1、抽象需求为对象
2、分析对象特性，包括属性和方法

### 重要知识
`js这种解释性的弱类型语言没有经典强类型语言中那种通过class等关键字实现的类的封装方式，js中都是通过一些特性模仿实现的，但这也带来了极高的灵活性，让我们编写的代码更自由`

js中模仿的oop特性：封装、继承

# 2024/1/21 20号已经粗略看过一次封装/继承内容

## 封装
`在js中创建类`：
生命一个函数，函数保存在一个变量里，在这个函数/类的内部通过对this（函数内部变量，指向函数本身）变量添加属性或方法来实现对雷添加属性或方法。代码示例如下（封装类Book）
//封装类、类的属性
var Book = funtion(id, bookname, price){
    this.id = id;
    this.bookname = bookname;
    this.price = price;
    <!-- this.doSomeThing = fucntion(){
        //xxx
    } -->
}
//封装类的方法
通过在类的原型（类也是一个对象，所以也原型prototype）上添加属性和方法。有两种方式，一为为原型对象属性赋值，二为将一个对象赋值给类的原型对象。代码示例：
Book.prototype.display = funtion(){
    //xxx
}
或
Book.prototype = {
    display : function(){
        //xxx
    }
}
以上两种方法是在“类”里面创建方法/函数
注意：
1、`js中类是通过js的特性来模仿出来的，本身并没有类这种类型`
2、每一种对象都有原型prototype，函数function也是一种对象

使用上面封装的Book类：
不能直接使用，要用`new`关键字来实例化（创建）新的对象。示例如下
var book = new Book('111', '设计模式'，50);
console.log(book.bookname);

`重要问题`：
通过this添加的属性和方法，与通过原型prototype添加的属性和方法，其差异是什么？
答：
1、通过this添加的属性和方法，都是添加在当前对象上的（是对象自身拥有的）。当创建该对象的实例时，这些属性和方法会被复制（创建一份）给到实例（复制过程是有消耗的）；
2、通过原型prototype继承的属性和方法是每个对象通过prototype访问到的，所以创建类的实例（新对象）时，这些属性和方法不会再次创建。都是通过prototype一级一级查找得来的，即是在原型prototype上有一份公共的，无需每次创建（消耗更低）。

`重要基础知识`：
js是一种基于原型prototype的语言，每次创建一个对象时（js中函数也是一种对象），他都有一个原型prototype用于指向其继承的属性，方法。通过prototype继承的方法并不是对象自身的。使用这些方法时，需通过prototype一级一级查找。

`Book类及其实例book关系解析示例解析`
如上创建的类Book，其实例对象book：
其属性（id，bookname，price）都会被复制一份到实例对象book中，但方法display不会复制到book中。如果book实例要访问display方法，需要通过book实例中prototype对象“_proto_”去往上一级一级寻找，直到找到display方法

### Book类中constructor是什么？
constructor是一个属性，当创建一个函数或对象时都会为其创建一个原型对象prototype，在prototype对象中会创建一个constructor属性，该属性指向拥有整个原型对象的函数或对象。
如上面例子，`prototype指向Book类对象`。

`感受`：
类/对象A - this
类/对象A - prototype - constructor(指向类/对象A)

高级语言如C#、java中其对象包含的属性和方法访问级别为：
private - 私有，只有对象内部可以访问
protected - 保护，只有对象自己可以访问
public - 公共/共有，外部对象可以访问
static - 静态属性或方法，全局只有一份

`js语言本身没有class，也没有private等几种访问级别控制，而是通过一些灵活的技巧来实现的`。就如同使用特性来模拟的类，本身并不直接支持。

js实现private、protected、public、static的方法：
js的`函数级作用域`:
1、声明在函数内部的变量和方法在外部是访问不到的，通过此特性即可创建类的私有变量和私有方法；
2、在函数内部通过this创建的属性和方法，在类创建对象时每个对象自身都拥有一份并且可在外部访问。因此通过this创建的属性和方法是对象共有属性和共有方法。通过this创建的方法，不但可以访问对象的共有属性和共有方法，还可访问到私有属性和私有方法，由于这些方法权利比较大，又叫做`特权方法`（共有方法又叫做特权方法）。
`特权方法`可用于初始化实例对象的一些属性，因此在创建对象时调用的特权方法看作是`类的构造器`。
3、
4、


`js：private` - 在函数内部声明变量和方法
var Book = function(){
    //私有属性
    var price = 10;
    //私有方法
    var display = function(){
        //xxx
    };
    //私有方法
    fucntion checkId(){
        //xxx
    }
}
`js：public` - 通过this创建属性和方法
js：public - 通过this创建的属性和方法 或 给类的prototype赋值
方法一：
var Book = function(id, name, price){
    //公有属性
    this.price = 10;
    //公有方法
    this.display = function(){
        //xxx
    };
    this.setName = function(){};
    this.setPrice = function(){};
    //构造器
    this.setName(name);
    this.setPrice(price);
}
方法二：
Book.prototype = {
    //公有属性
    isJSBook : false,
    //公有方法
    display : function(){}
}
`js：protected` - 不涉及
`js：static` - 通过类加点语法创建
//类静态公有属性（对象不能访问）
Book.isChinese = true;
//类静态公有方法（对象不能访问）
Book.resetTime = function(){};

`结论`：通过js函数级作用域的特征来实现在函数内部创建外界访问不到的私有化变量和私有方法。

摘抄:
通过new关键字创建的对象实质是对新对象this的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法语法定义的属性方法是不会添加到新创建的对象上去的。因此想在新创建对象上使用isChinese的通过Book类访问而不是this，如Book.isChinese，而`类的原型prototype上定义的属性在新对象里可直接使用，这是因为新对象的prototype和类的protyotype指向同一个对象`。
var b = new Book(xxx);
b.isJSBook  //可正常访问

`疑问`：
1、通过new关键字创建对象，为什么类外面通过点语法（Book.isChinese）添加的属性和方法不会被执行到？
2、new关键字是一个什么实现原理？

# 2024/1/25 new关键字实现
参考链接：https://www.jianshu.com/p/4bbf0c582e97

js中new关键字用来创建一个类（模拟类）的实例对象。

js中使用new关键字创建新对象，实际做了如下`4件事`：
1、创建一个新的空对象 {}
2、设置这个对象原型指向构造函数， 即上例中的obj.__proto = Person.prototype
3、执行构造函数， 当this关键字被提及的时候， 使用新创建的对象的属性
4、返回新创建的对象
//new关键字使用
var person = new Person("james", 18);
//new关键实现伪代码
new Person("james", 18) = {
    var obj = {};
    obj.__proto__ = Person.prototype;
    var res = Person.call(obj, "james", 18);
    return typeof res === "object" ? res : obj;
}

问：`new的本质`是什么？
答：语法糖，省略了创建对象所需的模版代码

疑问：call关键字实现原理是什么？

# 2024/1/26 构造函数和普通函数

摘自网络：
`js中构造函数和普通函数是两种不同类型的函数。构造函数用于创建对象，而普通函数用于执行一般的计算或操作`
构造函数：
function Person(name ,age){
    this.name = name;
    this.age = age;
}
普通函数：
function sayHello(){
    //实际代码实现，普通函数相对构造函数比较少见，因为一般的函数内部会定义变量等的场景都挺多
    console.log('xxx');
}
`感受`：
1、当通过new关键字创建类的实例对象时（比如：new Person("ll", 18)），定义Person类的整个function里面所有代码都会被执行一遍
2、定义Person类的整个function就是构造函数（的代码体）
3、普通函数里面不会定义私有或共有变量和方法，但普通函数也可以使用new关键字去创建对象实例，语法上不会报错，输出的不是新对象，而是内部逻辑输出的其他数据类型，比如字符串等
4、重点体会到了：js中构造函数返回的是一个对象实例，这是跟普通函数一个明确的区别

`理解提升了`：
摘抄:
"通过new关键字创建的对象实质是对新对象this的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性方法是不会添加到新创建的对象上去的。"
对如上摘抄内容的理解：
1、定义的Person函数本身就是构造函数，“new Person（xxx）”创建类实例对象时，执行的构造函数就是把Person函数本身所有代码执行了一遍，代码大部分代码是“this.xx = xxx”，所以说都是在对this不断赋值（实际是忘this对象上不断添加属性和方法，并给属性和方法赋值）
2、通过点语法在类上创建的属性，不在Person函数或者说构造函数内的，创建实例对象的时候是不会执行这些在类上通过点语法创建的属性的（Person.xxx），其调用也要使使用“类.xxx”方式，而非实例对象去调用

## 闭包实现 `重点知识`
var Book = (function(){
    //静态私有变量
    var bookNum = 0;
    //静态私有方法
    function checkBook(name){}；
    //返回构造函数（`return返回的函数即为闭包/闭包函数`）
    return function(newId, newName, newPrice){
        //私有变量
        var name, price;
        //私有方法
        function checkID(id){};
        //特权方法（公有方法）
        this.getName = function(){};
        this.getPrice = function(){};
        this.setName = function(){};
        this.setPrice = function(){};
        //公有属性
        this.id = newId;
        //公有方法
        this.copy = function(){};
        bookNum++; //`重点：访问外部函数的变量`
        if(bookNum > 100){
            throw new Error('xxx 100');
        };
        //构造器
        this.setName(name);
        this.setPrice(price);
    }
}
)();
Book.prototype = {
    //静态公有属性
    isJSBOOK : false,
    //静态公有方法
    diaplay : function(){}
}
`闭包概念`：
"闭包是有权访问另外一个函数作用域中变量的函数,即在一个函数内部创建另外一个函数。闭包是创建对象的构造函数，它既是闭包又是可实例化对象的函数，即可访问到类函数作用域（包裹闭包的外层函数）中的变量，如上面例子里的bookNum变量，这个变量此时叫静态私有变量，checkBook叫静态私有方法。闭包内部也有其自身的私有变量和私有方法，如price、checkID。如果要在闭包外部添加原型属性和方法，则可以在闭包的内部实现一个完整的类，再返回这个类。见如下实例："
var Book = (function(){
    var bookNum = 0;
    function checkBook(name){};
    function _book(newId, newName, newPrice){
        var name, price;
        function checkID(id){};
        this.getName = function(){};
        this.getPrice = function(){};
        this.setName = function(){};
        this.setPrice = function(){};
        this.id = newId;
        this.copy=function(){}
        bookNum++;
        if(bookNum > 100){
            throw new Error('xxxx');
        };
        //构造器
        this.setName(name);
        this.setPrice(price);
    };
    //给闭包声明原型属性和方法
    _book.prototype = {
        isJSBOOK:false,
        display:function(){}
    };
    //返回完整类
    return _book;
})();

### 创建对象的安全模式
1、创建对象不使用new关键字会发生什么情况？
2、怎样保证创建对象`忘记使用new关键字`依然可以正常实例化？

var Book = function(name , price){
    this.name = name;
    this.price = price;
}

#### 创建对象`不用new关键字`，如下：
var book = Book("11", 12);
结果是：
类内部对this的赋值操作都会变成对window对象的赋值，此时this指向window。
同时调用不会返回一个实例对象（用new关键字会最终返回实例对象），所以book是undefined。
`感受`：
可以理解为，不使用new关键字就是在纯粹的当作函数来调用(不是在创建对象，不会指向new关键字的4步代码)，this就指向window。

#### 保证`忘记用new关键字`依然可以正常实例并返回对象的措施：
var Book = function(name, price){
    //措施：先判断this的类型是否就是当前类，如果不是（比如指向window则手动调整代码）则手动添加new关键字调用实例化语句
    if(this instanceof Book){
        this.name = name;
        this.price = price;
    }else{
        //手动添加new关键字
        return new Book(name, price);
    }
}

## 继承
`继承是设计模式的灵魂`

`类可分三部分 - 部分一`：构造函数，主体内容，实例化时执行的代码（通过实例对象调用）
var BOOK = function(name , price){
    var name, price;
    this.setName = function(){};
    this.getName = function(){};
    this.setPrice = function(){};
    this.getPrice = function(){};
    this.name = this.getName();
    this.price = this.getPrice();
}

`类可分三部分 - 部分二`：原型赋值（通过实例对象调用）
BOOK.prototype = {
    version : "1.0";
    getProducer : function(){};
}

`类可分三部分 - 部分三`：点语法在类上添加的属性和方法（通过类调用）
BOOK.isJSBOOK = true;
BOOK.display = function(){};

=======================

js本身并没有“继”承这个特性，但可通过其他方式实现：
`继承方法一`：类式继承(第二个类的原型prototype被赋予了第一个类的实例)

“类的原型对象prototype的作用就是为类的原型添加共有方法，”

`类式继承原理`：xxx

可以通过`instanceof`来检测某个对象是否时某个类的实例，或者说某个对象是否继承了某个类。可用来判断对象和类之间的继承关系。

创建的所有对象都是Object的实例。

类式继承的缺点有2:
1、xxx
2、xxx



## 多态







