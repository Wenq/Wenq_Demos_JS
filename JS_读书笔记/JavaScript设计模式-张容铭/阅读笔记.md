# 2024/1/18
阅读了第118页的观察者模式内容

作功能模块实现，分析方法还是要走面向对象方法

# 2024/1/20 第一章 灵活的语言 - Javascript

## 把多个挂全局对象window上的function统一到一个window.xx对象/变量下，更加方便管理，function被覆盖风险更低，如果被覆盖也更容易察觉；

//写法1:在一个对象上创建函数
var CheckObject = {
    checkName : function(){
        //xxx
    }
}
用法：CheckObject.checkName()

//写法2:在一个函数上创建函数
var CheckObject = function(){}
CheckObject.checkName = function(){
    //xxx
}
用法：CheckObject.checkName()

`结论`：函数也是变量

//写法3: 返回一个对象
var CheckObject = function(){
    return {
        checkName : function(){
            //xxx
        }
    }
}
用法：CheckObject().checkName()
备注：每次ChckObject返回的都是一个新对象，整体是一个函数类型变量

`感受`：`链式调用`实现的重点是每一次调用返回的都是当前对象本身，即this

//写法4:类的方式
var CheckObject = function(){
    this.checkName = function(){
        //xxx
    }
}
用法：new CheckObject().checkName();  //类，用new创建（示例化）
备注：通过this定义的函数，用new关键字创建时会对this上的属性进行复制，即面向对象中类的定义与实例化

//写法5:类的其他实现方式
var CheckObject = function(){}
CheckObject.prototype.checkName = function(){
    //xxx
}
或者
var CheckObject = function(){}
CheckObject.prototype = {
    checkName : function(){
        //xxx
    },
    checkEmail : function(){
        //xxx
    }
}
用法：与写法4相同
备注：使用原型prototype实现类,比写法4性能更好（消耗低）

//写法5支持链式调用
var CheckObject = function(){}
CheckObject.prototype = {
    checkName : function(){
        //xxx
        return this;
    },
    checkEmail : function(){
        //xxx
        return this;
    }
}
链式调用：new CheckObject().checkName().checkEmail();

### 知识 - prototype.js框架

是一款js框架，封装了很多方法，用于扩展原生对象（比如Function、Arrya、Obejct等）

比如在原生Function对象上统一新增一个函数，这样任意地方都可以调用：
Fucntion.prototype.checkMail = function(){
    //xxx
}

备注：这种扩展也是对原生对象Function的`污染`

避免污染方法：
在Function原型上实现一个addMethod用于给实例对象动态添加函数，代码如下
Function.prototype.addMethod = function(name, fun){
    this[name] = fun;
}
使用示例：
var methods = new Function();
methods.addMethod = ('checkName', function(){
    //xxx
})
//调用动态增加的函数
methdos.checkName();
备注：这样做虽然也在Function的原型上添加了函数，但函数与具体业务逻辑无关







